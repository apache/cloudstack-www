"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1657],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return k}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),u=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=u(e.components);return n.createElement(o.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=u(a),h=i,k=m["".concat(o,".").concat(h)]||m[h]||p[h]||s;return a?n.createElement(k,r(r({ref:t},d),{},{components:a})):n.createElement(k,r({ref:t},d))}));function k(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,r=new Array(s);r[0]=h;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[m]="string"==typeof e?e:i,r[1]=l;for(var u=2;u<s;u++)r[u]=a[u];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},2652:function(e,t,a){a.r(t),a.d(t,{assets:function(){return o},contentTitle:function(){return r},default:function(){return m},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return u}});var n=a(3117),i=(a(7294),a(3905));const s={},r="Kvrocks data structures design",l={unversionedId:"data-structure-on-rocksdb",id:"data-structure-on-rocksdb",title:"Kvrocks data structures design",description:"Kvrocks uses the RocksDB as storage, it's developed by Facebook which is built on LevelDB with many extra features, like column family, transaction and backup, see the RocksDB wiki: Features Not In LevelDB. The basic operations in RocksDB are Put(key, value), Get(key), Delete(key), other complex structures aren't supported.",source:"@site/community/data-structure-on-rocksdb.md",sourceDirName:".",slug:"/data-structure-on-rocksdb",permalink:"/build/community/data-structure-on-rocksdb",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"community",previous:{title:"Internals",permalink:"/build/community/category/internals"},next:{title:"Releases",permalink:"/build/community/category/releases"}},o={},u=[{value:"String",id:"string",level:2},{value:"Hash",id:"hash",level:2},{value:"hash metadata",id:"hash-metadata",level:4},{value:"hash sub keys-values",id:"hash-sub-keys-values",level:4},{value:"Set",id:"set",level:2},{value:"List",id:"list",level:2},{value:"list metadata",id:"list-metadata",level:4},{value:"list sub keys-values",id:"list-sub-keys-values",level:4},{value:"ZSet",id:"zset",level:2},{value:"zset metadata",id:"zset-metadata",level:4},{value:"zset sub keys-values",id:"zset-sub-keys-values",level:4},{value:"Bitmap",id:"bitmap",level:2},{value:"bitmap metadata",id:"bitmap-metadata",level:4},{value:"bitmap sub keys-values",id:"bitmap-sub-keys-values",level:4},{value:"SortedInt",id:"sortedint",level:2},{value:"Stream",id:"stream",level:2},{value:"stream metadata",id:"stream-metadata",level:4},{value:"stream sub keys-values",id:"stream-sub-keys-values",level:4}],d={toc:u};function m(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"kvrocks-data-structures-design"},"Kvrocks data structures design"),(0,i.kt)("p",null,"Kvrocks uses the RocksDB as storage, it's developed by Facebook which is built on LevelDB with many extra features, like column family, transaction and backup, see the RocksDB wiki: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebook/RocksDB/wiki/Features-Not-in-LevelDB"},"Features Not In LevelDB"),". The basic operations in RocksDB are ",(0,i.kt)("inlineCode",{parentName:"p"},"Put(key, value)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Get(key)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Delete(key)"),", other complex structures aren't supported."),(0,i.kt)("p",null,"The main goal of this doc is to explain how we build the Redis hash/list/set/zset/bitmap/stream on RocksDB. Most of the design were derived from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Qihoo360/blackwidow"},"Qihoo360/Blackwidow"),", but with little modification, like the bitmap design, it's a fascinating part."),(0,i.kt)("h2",{id:"string"},"String"),(0,i.kt)("p",null,"Redis string is key-value with expire time, so it's very easy to translate the Redis string into RocksDB key-value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+--------------------+\nkey =>  |  flags   |  expire    |       payload      |\n        | (1byte)  | (4byte)    |       (Nbyte)      |\n        +----------+------------+--------------------+\n")),(0,i.kt)("p",null,"We prepend 1-byte ",(0,i.kt)("inlineCode",{parentName:"p"},"flags")," and 4-bytes expire before the user's value:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"flags")," is used to tell the Kvrocks which type of this key-value, maybe ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"hash"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"list"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"zset"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"bitmap"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"stream")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expire")," stores the absolute time of key should be expired, zero means the key-value would never expire"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"payload")," is the user's raw value")),(0,i.kt)("h2",{id:"hash"},"Hash"),(0,i.kt)("p",null,"Redis hashmap(dict) is like the hashmap in many programming languages, it is used to implement an associative array abstract data type, a structure that can map keys to values. The direct way to implement the hash in RocksDB is serialized the keys/values into one value and store it like the string, but the drawback is performance impact when the keys/values grew bigger. so we split the hash sub keys/values into a single key-value in RocksDB, track it with metadata."),(0,i.kt)("h4",{id:"hash-metadata"},"hash metadata"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (4byte)    |  (8byte)  | (4byte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("p",null,"The value of key we call it metadata here, it stored the metadata of hash key includes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"flags")," like the string, the field shows what type this key is"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expire ")," is the same as the string type, record the expiration time"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"version")," is used to accomplish fast delete when the number of sub keys/values grew bigger"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"size")," records the number sub keys/values in this hash key")),(0,i.kt)("h4",{id:"hash-sub-keys-values"},"hash sub keys-values"),(0,i.kt)("p",null,"We use extra keys-values to store the hash keys-values, the format is like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                     +---------------+\nkey|version|field => |     value     |\n                     +---------------+\n")),(0,i.kt)("p",null,"We prepend the hash ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"version")," before the hash field, the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"version")," is from the metadata. For example, when the request ",(0,i.kt)("inlineCode",{parentName:"p"},"hget h1 f1")," is received, Kvrocks fetches the metadata by hash key(here is ",(0,i.kt)("inlineCode",{parentName:"p"},"h1"),"), then concatenate the hash key, version, field as new key, then fetches the value with the new key."),(0,i.kt)("admonition",{title:"Why store version in the metadata?",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"We store the hash keys/values into a single key-value, if the store millions of sub keys-values in one hash key. If user delete this key, the Kvrocks must iterator millions of sub keys-values and delete them, which would cause performance problem. With version, we can quickly delete the metadata and then recycle the others keys-values in compaction background threads. The cost is those tombstone keys would take some disk storage. You can regard the version as an atomic increment number, but it's combined with a timestamp.")),(0,i.kt)("admonition",{title:"What can we do if the user key is conflicted with the composed key?",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"We store the metadata key and composed key in different column families, so it wouldn't happen.")),(0,i.kt)("h2",{id:"set"},"Set"),(0,i.kt)("p",null,"Redis set can be regarded as a hash, with the value of sub-key always being null, the metadata is the same with the one in hash:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (4byte)    |  (8byte)  | (4byte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("p",null,"and the sub keys-values in RocksDB would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                      +---------------+\nkey|version|member => |     NULL      |\n                      +---------------+\n")),(0,i.kt)("h2",{id:"list"},"List"),(0,i.kt)("h4",{id:"list-metadata"},"list metadata"),(0,i.kt)("p",null,"Redis list is also organized by metadata and sub keys-values, and sub key is index instead of the user key. Metadata is like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |  head     |  tail     |\n        | (1byte)  | (4byte)    |  (8byte)  | (4byte)   | (8byte)   | (8byte)   |\n        +----------+------------+-----------+-----------+-----------+-----------+\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"head")," is the starting position of the list head"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tail")," is the stopping position of the list tail")),(0,i.kt)("p",null,"The meaning of other fields are the same as other types, just add extra head/tail to record the boundary of the list."),(0,i.kt)("h4",{id:"list-sub-keys-values"},"list sub keys-values"),(0,i.kt)("p",null,"The subkey in list is composed by list key, version and index, index is calculated from metadata's head or tail. for example, when the user requests the ",(0,i.kt)("inlineCode",{parentName:"p"},"rpush list elem"),", Kvrocks would fetch the metadata with list key, then generate the subkey with list key, version and tail, simply increase the tail, then write the metadata and subkey's value back to RocksDB."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                     +---------------+\nkey|version|index => |     value     |\n                     +---------------+\n")),(0,i.kt)("h2",{id:"zset"},"ZSet"),(0,i.kt)("p",null,"Redis zset is set with sorted property, so it's a little different from other types. it must be able to search with the member, as well as to retrieve members with score range."),(0,i.kt)("h4",{id:"zset-metadata"},"zset metadata"),(0,i.kt)("p",null,"The metadata of zset is still same with set, like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (4byte)    |  (8byte)  | (4byte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("h4",{id:"zset-sub-keys-values"},"zset sub keys-values"),(0,i.kt)("p",null,"The value of sub key isn't null, we need a way to range the members with the score. So the zset has two types of sub keys-values, one for mapping the members-scores, and one for score range."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                            +---------------+\nkey|version|member       => |     score     |   (1)\n                            +---------------+\n\n                            +---------------+\nkey|version|score|member => |     NULL      |   (2)\n                            +---------------+\n")),(0,i.kt)("p",null,"If the user wants to get the score of the member or check the member exists or not, it would try the first one."),(0,i.kt)("h2",{id:"bitmap"},"Bitmap"),(0,i.kt)("p",null,"Redis bitmap is the most interesting part in Kvrocks design, unlike other types, it's not subkey and the value would be very large if the user treats it as a sparse array. It's apparent that the things would break down if we store the bitmap into a single value, so we should break the bitmap value into multiple fragments. Another behavior of bitmap is writing to arbitrary index, it's very similar to the access model of the Linux virtual memory, so the idea of the bitmap design came from that."),(0,i.kt)("h4",{id:"bitmap-metadata"},"bitmap metadata"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (4byte)    |  (8byte)  | (4byte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("h4",{id:"bitmap-sub-keys-values"},"bitmap sub keys-values"),(0,i.kt)("p",null,"We break the bitmap values into fragments(1KiB, 8192 bits/fragment), and subkey is the index of the fragment. for example, when the request to set the bit of 1024 would locate in the first fragment with index 0, to set a bit of 80970 would locate in 10th fragment with index 9."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                     +---------------+\nkey|version|index => |    fragment   |\n                     +---------------+\n")),(0,i.kt)("p",null,"when the user requests to get it of position P, Kvrocks would first fetch the metadata with bitmap's key and calculate the index of the fragment with bit position, then fetch the bitmap fragment with composed key and find the bit in fragment offset. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"getbit bitmap 8193"),", the fragment index is ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," (8193/8192) and subkey is ",(0,i.kt)("inlineCode",{parentName:"p"},"bitmap|1|1")," (when the version is 1), then fetch the subkey from RocksDB and check if the bit of offset ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"(8193%8192) is set or not."),(0,i.kt)("h2",{id:"sortedint"},"SortedInt"),(0,i.kt)("p",null,"SortedInt is a set with members being type int and sorted in ascending order:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (4byte)    |  (8byte)  | (4byte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("p",null,"and the sub keys-values in RocksDB would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                  +---------------+\nkey|version|id => |      NULL     |\n                  +---------------+\n")),(0,i.kt)("h2",{id:"stream"},"Stream"),(0,i.kt)("p",null,"Each entry in a stream has its unique ID in the form of ",(0,i.kt)("inlineCode",{parentName:"p"},"MS-SEQ")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"MS")," is the number of milliseconds and ",(0,i.kt)("inlineCode",{parentName:"p"},"SEQ")," is the counter for entries added within the same millisecond. These two values are concatenated with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," (minus sign). The entry ID may be generated by the server or explicitly set by the client. A stream metadata tracks the ID of the last added entry."),(0,i.kt)("h4",{id:"stream-metadata"},"stream metadata"),(0,i.kt)("p",null,"Redis stream is organized by the metadata and sub keys-values. The metadata has fields mentioned before (",(0,i.kt)("inlineCode",{parentName:"p"},"flags"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"expiration"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"version"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"size"),") and additional fields, that are specific only for this data type. The structure of the metadata value is the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"flags")," (1 byte)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expiration")," (4 bytes)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"version")," (8 bytes)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"size")," (4 bytes)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LGE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the last generated entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LGE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the last generated entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"RFE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the very first entry ID that was added to the stream"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"RFE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the very first entry ID that was added to the stream"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MDE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the max deleted entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MDE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the max deleted entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the current first entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the current first entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the current last entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the current last entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"TNE")," (8 bytes) stores the total number of entries that were added to the stream during its lifetime")),(0,i.kt)("h4",{id:"stream-sub-keys-values"},"stream sub keys-values"),(0,i.kt)("p",null,"the sub-key in a stream is composed by the stream key, version and the entry ID. The entry ID is encoded as two consecutive 8-bytes integer values (",(0,i.kt)("inlineCode",{parentName:"p"},"EID MS")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"EID SEQ"),"). The stream entry value may represent any even number of strings. This value is encoded as a sequence of strings and each string value is prepended by its length as a 4-bytes variable integer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                              +-----------------------+\nkey|version|EID MS|EID SEQ => |     encoded value     |\n                              +-----------------------+\n")))}m.isMDXComponent=!0}}]);